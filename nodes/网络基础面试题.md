<!-- TOC -->

- [三种协议分层](#三种协议分层)
- [ARP是地址解析协议，简单语言解释一下工作原理](#arp是地址解析协议简单语言解释一下工作原理)
- [描述RARP协议](#描述rarp协议)
- [TCP三次握手](#tcp三次握手)
- [三次握手的必要性](#三次握手的必要性)
- [三次握手就是必要的吗？](#三次握手就是必要的吗)
- [三次握手出现错误应对措施](#三次握手出现错误应对措施)
- [四次挥手](#四次挥手)
- [TCP和UDP区别](#tcp和udp区别)

<!-- /TOC -->
# 三种协议分层 

**OSI分层** :物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

**TCP/IP分层（4层）** ：网络接口层、网际层、运输层、应用层。

**五层协议(5层)** ：物理层、数据链路层、网络层、运输层、应用层。

**常见的网络协议** ：

**网络层** ：

**IP协议** ：网际协议

**ICMP协议** ：Internet控制报文协议

**ARP协议** ：地址解析协议

**RARP协议** ：逆地址解析协议

**传输层** ：

**UDP协议** ：用户数据报协议

**TCP协议** ：传输控制协议

**应用层** ：

**FTP协议** ：文件传输协议

**Telenet** ：远程登录协议

**DNS** ：域名解析协议

**POP3** :邮局协议

**HTTP** :超文本传输协议

**SMTP** ：简单邮件传输协议

**SNMP** :简单文件传输协议

# ARP是地址解析协议，简单语言解释一下工作原理

1、首先每个主机都会在自己的ARP缓冲区中建立一个ARP列表，来表示IP地址和MAC地址之间的对应关系。

2、当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送，如果没有，就向网段的所有主机发送ARP数据包。

3、当本网络的所有主机收到该ARP数据包后，检查数据包中的IP地址是否是自己的IP地址，如果不是，则丢弃该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的。

4、源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表中，并以此信息，发送数据。如果源主机一直没收到ARP响应数据包，表示ARP查询失败。

# 描述RARP协议

RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为无盘工作站配置的IP不能保存。工作流程是：在网络中配置一台RARP服务器，里面保存着IP和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

# TCP三次握手

（1）第一次握手：建立连接时，客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器的确认。

（2）第二次握手：服务器收到SYN包后，必须确认客户端的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN_RECV状态。



（3）第三次握手：客户端收到服务器的SYN+ACK包后，向服务器发送确认包ACK（ACK+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

# 三次握手的必要性

考虑一次的问题，首先tcp是面向连接，一次握手肯定建立不了连接，因为客户机给服务器发出请求信息却没有得到回应，客户机是没法判定是否发送成功然后建立连接的。

再看两次，假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，再发送一个SYN，这次B顺利收到，接着A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费。

# 三次握手就是必要的吗？

两次握手的问题在于服务器端不知道一个SYN是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向Server写数据，Server端将以RST包响应，这时便感知到Server的错误。

总之，三次握手可以保证任何一次握手的失败都是可感知的，不会浪费资源

# 三次握手出现错误应对措施

第一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放

第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK

第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST

# 四次挥手

第一次挥手：当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。

第二次挥手：主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。

第三次挥手：主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。

第四次挥手：主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。
 
# TCP和UDP区别

1、TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按时到达；UDP是尽最大努力交付的，即不保证可靠交付。

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的。

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。

5、TCP首部开销20字节；UDP的首部开销小，只有8字节。

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。























