  
# 内存模型

## 一、运行时数据区
Java虚拟机管理的内存：方法区、虚拟机栈、堆、本地方法栈、程序计数器，其中方法区和堆是由线程共享的数据区，其他几个是线程隔离的数据区。  

### 1.1 程序计数器
程序计数器内存较小。如果线程正在执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器为空。  

### 1.2 Java虚拟机栈  
每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 

其中局部变量表存放编译期可知的各种基本数据类型、对象引用、returnAddress类型。  

该区域可能抛出以下异常：

1、当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；

2、栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。  

### 1.3 本地方法栈  
本地方法栈和虚拟机栈发挥的作用相似，他们的区别是虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。

### 1.4 Java堆  
堆是Java虚拟机所管理的内存中最大的一块，此内存区唯一的目的是存放对象实例。

Java堆是垃圾收集器管理的主要区域，所以被称为“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：老年代和新生代（新生代还可分为：Eden空间、From Survivor空间、To Survior空间）。  

Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，可以通过 -Xmx 和 -Xms 来控制动态扩展内存大小，如果动态扩展失败会抛出 OutOfMemoryError 异常。  

### 1.5 方法区  
方法区用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  

和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。  

这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般比较难实现，HotSpot 虚拟机把它当成永久代来进行垃圾回收。










